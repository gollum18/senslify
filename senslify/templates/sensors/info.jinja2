{% extends 'base.jinja2' %}

{% block head %}{% endblock %}

{% block header %}
    <h1>{{ title }} - Senslify</h1>
{% endblock %}

{% block content %}
    <h2>Displays Live Data and Recent Readings</h2>
    <section>
        <h3>Live Display for Sensor {{ sensor }}:</h3>
        <canvas id="canvas_chart" width="600" height="400"></canvas>
        <h6>Note: Live display will not update if the sensor is offline.</h6>
    </section>
    <section>
        <h3>Last {{ num_readings }} Readings for Sensor {{ sensor }}:</h3>
        <ul id="readings_display"></ul>
            {% for reading in readings %}<li>{{ reading }}<\li>{% endfor %}
        </ul>
    </section>
{% endblock %}

{% block footer %}
    <script href="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>
    <!-- The below script handles WebSocket and chart interaction -->
    <script>
        const readings_size = {{ num_readings }};  // The max size of the stack
        var readings;  // The display for the most recent readings
        var chart;  // The chart canvas itself
        // Get the sensor
        var sensor = {{ sensor }}; 
        // Used for sending and receiving updates to/from the server
        //  Exists for the duration of the user's visit to the page
        var ws = new WebSocket('{{ ws_url }}');

        // Defines a method for setting up variables once the DOM tree loads
        $(document).on("ready", function(e) {
            // get a reference to the chart and its context for drawing
            var ctx = $('#canvas_chart');
            chart = new Chart(ctx, {
                type: 'line'
            });
            // get a reference to the stack display
            readings = $('#readings_display');
        });

        // Defines a method for closing the socket connection when navigating away
        $(window).on("unload", function(e) {
            // Send a message to the server to close the connection
            ws.send(JSON.stringify({'cmd': 'CLOSE'}));
            // Close the connection
            ws.close();
        });

        // Registers the JOIN request to be sent to the server when the 
        //  WebSocket is open. This may fail, but is unlikely
        ws.onopen = function(e) {
            join_handler();
        }

        // Receives information from the server
        ws.onmessage = function(event) {
            // get the response sent by the server
            //  the server responds with JSON objects encoded as Strings,
            //  decode the string to a JSON object so we can work with it
            var msg = JSON.parse(event.data);
            
            // get the command from the server
            var cmd = msg.cmd;
            
            // route the message to the appropriate handler
            if (cmd === "READING") {
                reading_handler(msg.msg);
            }
        }
        
        /*
         * Define routing handlers for messages received by the server
         */
        
        // Sends a join request to the server
        function join_handler() {
            // construct the request for the server
            msg = {'cmd': 'JOIN', 'sensor': sensor};
            // send the request
            ws.send(JSON.stringify(msg));
        }
        
        // Handles readings as they come in from the server
        function reading_handler(reading) {
            if (validate_reading(reading)) {
                // update the chart
                update_chart(reading);
                // update the list
                update_list(reading);
            }
        } 
        
        /*
         * Defines support functions for the routing handlers
         */

        // Validates data received from the server
        function validate_reading(reading) {
            if (!reading.hasOwnProperty('ts') || reading.ts <= 0) {
                return false;
            }
            if (!reading.hasOwnProperty('value') || reading.value < 0) {
                return false;
            }
            return true;
        }

        // Defines a method for updating the chart when data is received
        function update_chart(reading) {
            // update the data array
            chart.data.datasets.forEach((dataset) => {
                dataset.data.push({'x': reading.ts, 'y': readings.value})
            });

            // updates the view on the chart
            chart.update();
        }
        
        // Defines a method for updating the reading display when a reading
        //  comes in from the socket
        function update_list(reading) {
            // check if the output is full
            if (readings.childElementCount === readings_size) {
                // remove the oldest reading
                readings.removeChild(readings.childNodes[0]);
            }
            
            // append the newest reading to the end of the display
            var node = document.createElement("LI");
            var textNode = document.createTextNode(reading);
            node.appendChild(textNode);
            readings.appendChild(node);
        }

    </script>
{% endblock %}
