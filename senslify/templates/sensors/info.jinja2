{% extends 'base.jinja2' %}

{% block head %}{% endblock %}

{% block header %}
    <h1>{{ title }} - Senslify</h1>
{% endblock %}

{% block content %}
    <h2>Displays Live Data and Recent Readings</h2>
    <section>
        <div>
            <h3>Live Display for Sensor {{ sensor }}:</h3>
            <canvas id="canvas_chart" width="600" height="400"></canvas>
            <h6>Note: Live display will not update if the sensor is offline.</h6>
        </div>
        <div>
            <!-- Used to indicate the reading type to send from server -->
            <label for="sel_rtype">Reading: </label>
            <select id="sel_rtype" onchange="change_stream_handler()">
                <option value="humidity">Humidity</option>
                <option value="light">Light</option>
                <option value="temp">Temperature</option>
                <option value="voltage">Voltage</option>
            </select>
        </div>
    </section>
    <section>
        <h3>Last {{ num_readings }} Readings for Sensor {{ sensor }}:</h3>
        <ul id="readings_display"></ul>
            {% for reading in readings %}<li>{{ reading }}<\li>{% endfor %}
        </ul>
    </section>
{% endblock %}

{% block footer %}
    <!-- Pulls down the Chart.js script for this file only. -->
    <script href="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>
    <!-- The below script handles WebSocket and chart interaction -->
    <script>
        const readings_size = {{ num_readings }};  // The max size of the stack
        var sel_rtype;  // The selector for choosing which reading to receive
        var readings;  // The display for the most recent readings
        var chart;  // The chart canvas itself
        var ctx;    // The 2d context for drawing
        // Get the sensor
        var sensor = {{ sensor }}; 
        // Used for sending and receiving updates to/from the server
        //  Exists for the duration of the user's visit to the page
        var ws = new WebSocket('{{ ws_url }}');

        // Defines a method for setting up variables once the DOM tree loads
        $(document).on("ready", function(e) {
            // get a reference to the reading select
            sel_rtype = document.getElementById('sel_rtype');
            // get a reference to the chart and its context for drawing
            ctx = document.getElementById('canvas_chart').getContext("2d");
            chart = new Chart(ctx, {
                type: 'line'
            });
            // get a reference to the stack display
            readings = document.getElementById('readings_display');
        });

        // Defines a method for closing the socket connection when navigating away
        $(window).on("unload", function(e) {
            // Send a message to the server to close the connection
            ws.send(JSON.stringify({'cmd': 'CLOSE'}));
            // Close the connection
            ws.close();
        });

        // Registers the JOIN request to be sent to the server when the 
        //  WebSocket is open. This may fail, but is unlikely
        ws.onopen = function(e) {
            join_handler();
        }

        // Receives information from the server
        ws.onmessage = function(event) {
            // get the response sent by the server
            //  the server responds with JSON objects encoded as Strings,
            //  decode the string to a JSON object so we can work with it
            var msg = JSON.parse(event.data);
            
            // get the command from the server
            var cmd = msg.cmd;
            
            // route the message to the appropriate handler
            if (cmd === "READING") {
                reading_handler(msg.msg);
            }
        }
        
        /*
         * Define routing handlers for messages received by the server
         */
        
        // Sends a join request to the server
        function join_handler() {
            // construct the request for the server
            msg = {'cmd': 'JOIN', 'sensor': sensor};
            // send the request
            ws.send(JSON.stringify(msg));
        }
        
        // Handles readings as they come in from the server
        function reading_handler(reading) {
            if (validate_reading(reading)) {
                // update the chart
                update_chart(reading);
                // update the list
                update_list(reading);
            }
        } 

        // Handles changing the reading that the page is receiving for the sensor
        function change_stream_handler() {
            
        }
        
        /*
         * Defines support functions for the routing handlers
         */

        // Validates data received from the server
        function validate_reading(reading) {
            // TODO: Validate the data received from the server
            return true;
        }

        // Defines a method for updating the chart when data is received
        function update_chart(reading) {
            // TODO: Update the chart with the data from the server
        }
        
        // Defines a method for updating the reading display when a reading
        //  comes in from the socket
        function update_list(reading) {
            // check if the output is full
            if (readings.childElementCount === readings_size) {
                // remove the oldest reading
                readings.removeChild(readings.childNodes[0]);
            }
            
            // append the newest reading to the end of the display
            var node = document.createElement("LI");
            var textNode = document.createTextNode(reading);
            node.appendChild(textNode);
            readings.appendChild(node);
        }

    </script>
{% endblock %}
