{% extends 'base.jinja2' %}

{% block head %}    
    <!-- Pulls down the Chart.js script for this file only. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.js"></script>
{% endblock %}

{% block header %}
    <h1>{{ title }} - Senslify</h1>
{% endblock %}

{% block content %}
    <h2>Displays Live Data and Recent Readings</h2>
    <section>
        <div>
            <canvas id="canvas_chart" width="600" height="400"></canvas>
            <h6>Note: Live display will not update if the sensor is offline.</h6>
        </div>
        <div>
            <!-- Used to indicate the reading type to send from server -->
            <label for="sel_rtype">Reading: </label>
            <select id="sel_rtype" onchange="onStreamChanged();">
                {% for rtype in rtypes %}
                    <option value="{{ rtype.rtypeid }}">{{ rtype.rtype }}</option>
                {% endfor %}
            </select>
        </div>
    </section>
    <section>
        <h3>Last {{ num_readings }} Readings for Sensor {{ sensorid }}:</h3>
        <ol id="list_readings"></ol>
    </section>
{% endblock %}

{% block footer %}
    <!-- The below script handles WebSocket and chart interaction. -->
    <script>
        
        //
        // Define all necessary script variables
        //
        
        // the number of readings to retrieve from the server
        const rlim = {{ num_readings }};
        // the id of the sensor to receive messages for
        const sensorid = {{ sensorid }};
        // the id of the group the sensor belongs to
        const groupid = {{ groupid }};
        // the websocket for sending/receiving messages to/from the server
        //  the websocket is constant as it persists for the life of the page
        const ws = new WebSocket('{{ ws_url }}');
        // stores a reference to the chart object for graphically displaying 
        //  readings
        var chart = null;
        
        //
        // Define handlers for the window
        //
        
        /**
         * Fired when the user navigates away from the page.
         * Signals a teardown of the WS at the server as well to teardown the
         * WS on the client.
         */
        function onWindowUnload() {
            var msg = {'cmd': 'RQST_CLOSE', 'sensorid': sensorid};
            ws.send(JSON.stringify(msg));
            ws.close();
        }
        
        // Register JQuery window event handlers
        $(window).on("unload", onWindowUnload);
        
        //
        // Define handlers for the WebSocket
        //
        
        /**
         * Client side WS handler that requests the server to enqueue the 
         * WS representing this client to receive messages for the sensor
         * indicated by sensorid.
         */
        function joinHandler() {
            var rqst = {'cmd': 'RQST_JOIN', 'sensorid': sensorid};
            ws.send(JSON.stringify(rqst));
        }
        
        /**
         * Client side WS handler that handles received messages (readings)
         * from the server. The client only receives readings for the 
         * sensorid and rtypeid that it has registered to receive updates on.
         * @param resp The response from the server.
         */
        function readingHandler(resp) {
            // get the list of readings
            var rlist = $("#list_readings");
            
            // evict the oldest reading if at the limit
            if (rlist.children().length === rlim) {
                rlist.children().last().remove();
            }
            
            // add the reading to the front of the list
            $('<li/>')
                    .text(resp.readings[0].rstring)
                    .prependTo($("#list_readings"));
        }
        
        /**
         * Client side WS handler that handles received messages (a dataset)
         * from the server. The client receives an up-to-date dataset containing
         * the top 100 most recent readings for the sensorid and rtypeid they
         * are registered with.
         * @param resp The response from the server.
         */ 
        function streamHandler(resp) {
            // get the readings from the response
            var readings = resp.readings;
            
            // reset the chart
            resetChart(resp.readings);
            
            // reset the list
            resetList(resp.readings)
        }
        
        /**
         * Client side WS handler that fires when the WebSocket first opens.
         * This is used by the client to register the sensor it wants to
         * receive updates for.
         * @param err An error if one occurs.
         */
        function onWSOpen(err) {
            joinHandler();
            onStreamChanged();
        }
        
        /**
         *
         */
        function onWSReceive(msg) {
            // Parse the response from the server
            var resp = JSON.parse(msg.data);
            
            // route the message based on response command
            if (resp.cmd === "RESP_READING") { // handles individual readings
                readingHandler(resp);
            } else if (resp.command = "RESP_STREAM") { // handles whole datasets
                streamHandler(resp);
            }
        }
        
        // Register handlers for the WebSocket
        ws.onopen = onWSOpen;
        ws.onmessage = onWSReceive;
        
        //
        // Define additional support functions
        //
        
        /**
         * Constructs a new ChartJS line chart.
         * @param raw_dataset The dataset to intialize the chart with.
         */
        function createChart(raw_dataset) {
            // reverse the dataset, the server sends it in descending order on timestamp
            raw_dataset.reverse();
            
            // construct the dataset
            var dataset = [];
            raw_dataset.forEach(function(reading) {
                dataset.push({
                    x: new Date(reading.ts),
                    y: reading.val
                });
            });
            
            // get the context for the chart
            var ctx = $('#canvas_chart')[0].getContext('2d');
            
            // return the chart
            return new Chart(ctx, {
                type: 'line',
                data: dataset,
                options: {
                    display: true,
                    text: "Time Series for Sensor: {{ sensorid }}"
                }
            });
        }
        
        /**
         * Resets the chart with a new dataset.
         * @param dataset The dataset to load into the chart.
         */
        function resetChart(dataset) {
            if (chart != null) {
                // destroy the original chart
                chart.destroy();
            }
            
            // rebuild the chart
            chart = createChart(dataset);
        }
        
        /**
         * Resets the list with a new dataset.
         * @param dataset The dataset to load into the list.
         */
        function resetList(dataset) {
            dataset.reverse();
        
            // empty display of all children
            $("#list_readings").empty();
            
            // rebuild the list with the new values
            dataset.forEach(function(reading) {
                $('<li/>')
                    .text(reading.rstring)
                    .appendTo($("#list_readings"));
            });
        }
        
        /**
         * Handles onchange events for the rtype selector.
         */
        function onStreamChanged() {
            var rtypeid = $("#sel_rtype").val()
            
            var msg = {
                'cmd': 'RQST_STREAM',
                'sensorid': sensorid,
                'groupid': groupid,
                'rtypeid': rtypeid
            };
            
            ws.send(JSON.stringify(msg));
        }
    </script>
{% endblock %}
