{% extends 'base.jinja2' %}

{% block head %}    
    <!-- Pulls down the Chart.js script for this file only. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.js"></script>
{% endblock %}

{% block header %}
    <h1>{{ title }} - Senslify</h1>
{% endblock %}

{% block content %}
    <h2>Displays Live Data and Recent Readings</h2>
    <section>
        <div>
            <canvas id="canvas_chart" width="600" height="400"></canvas>
            <h6>Note: Live display will not update if the sensor is offline.</h6>
        </div>
        <div>
            <!-- Used to indicate the reading type to send from server -->
            <label for="sel_rtype">Reading: </label>
            <select id="sel_rtype" onchange="change_stream_handler();">
                {% for rtype in rtypes %}
                    <option value="{{ rtype.rtypeid }}">{{ rtype.rtype }}</option>
                {% endfor %}
            </select>
        </div>
    </section>
    <section>
        <h3>Last {{ num_readings }} Readings for Sensor {{ sensorid }}:</h3>
        <ol id="readings_display"></ol>
            {% for reading in readings %}<li>{{ reading }}<\li>{% endfor %}
        </ol>
    </section>
{% endblock %}

{% block footer %}
    <!-- The below script handles WebSocket and chart interaction -->
    <script>
        function createChart() {
            return new Chart(document.getElementById("canvas_chart"), {
                type: "line",
                options = {
                    display: true,
                    text: "Time Series for Sensor {{ sensorid }}"
                }
            });
        }
        
        const readings_size = {{ num_readings }};  // The max size of the stack
        var readings = document.getElementById("readings_display");  // The display for the most recent readings
        var chart = createChart();
        // Get the sensor
        var sensorid = {{ sensorid }};
        // Used for sending and receiving updates to/from the server
        //  Exists for the duration of the user's visit to the page
        var ws = new WebSocket('{{ ws_url }}');

        // Defines a method for closing the socket connection when navigating away or refreshing the page
        $(window).on("unload", function(e) {
            // Send a message to the server to close the connection
            ws.send(JSON.stringify({'cmd': 'CLOSE', 'sensorid': sensorid}));
            // Close the connection
            ws.close();
        });

        // Registers the JOIN request to be sent to the server when the 
        //  WebSocket is open. This may fail, but is unlikely
        ws.onopen = function(e) {
            join_handler();
        }

        // Receives information from the server
        ws.onmessage = function(event) {
            // get the response sent by the server
            //  the server responds with JSON objects encoded as Strings,
            //  decode the string to a JSON object so we can work with it
            var pkt = JSON.parse(event.data);
            // get the command from the server
            var cmd = pkt.cmd;
            // route the message to the appropriate handler
            if (cmd === "READING") {
                reading_handler(pkt);
            }
        }
        
        /*
         * Define routing handlers for messages received by the server
         */
        
        // Sends a join request to the server
        function join_handler() {
            // construct the request for the server
            msg = {'cmd': 'JOIN', 'sensorid': sensorid};
            // send the request
            ws.send(JSON.stringify(msg));
        }
        
        
        /**
         * Defines a function for handling received readings from the server.
         */
        function reading_handler(pkt) {
            if (validate_reading(pkt)) {
                // update the chart
                update_chart(pkt);
                // update the list
                update_list(pkt);
            }
        } 
        
        
        /**
         *
         */
        function resetDisplay() {
            // TODO: Reset the Chart
            chart.destroy();
            chart = createChart();
            // Reset the list
            while (readings.firstChild) {
                readings.removeChild(readings.firstChild);
            }
        }

        
        /**
         * Defines a function for changing the type of readings that the client 
         * gets streamed from the server.
         */
        function change_stream_handler() {
            // get the selected rtype
            var rtypeid = $("select#sel_rtype option:checked").val();
            // create the rtype switch message
            msg = {'cmd': 'STREAM', 'sensorid': sensorid, 'rtypeid': rtypeid};
            // send it to the server
            ws.send(JSON.stringify(msg));
            // reset the chart and list
            resetDisplay();
        }
        
        /*
         * Defines support functions for the routing handlers
         */

        // Validates data received from the server
        function validate_reading(reading) {
            // make sure all required fields are present
            if (!reading.hasOwnProperty('rtypeid')) {
                return false;
            }
            if (!reading.hasOwnProperty('ts') || reading.ts <= 0) {
                return false;
            }
            if (!reading.hasOwnProperty('val') || reading.val < 0) {
                return false;
            }
            // pass on packets that do not match the rtype
            if (reading.rtypeid != $("select#sel_rtype option:checked").val()) {
                return false;
            }
            return true;
        }

        // Defines a method for updating the chart when data is received
        function update_chart(reading) {
            // update the data array
            chart.data.datasets.forEach((dataset) => {
                dataset.data.push({
                    'x': new Date(reading.ts), 'y': reading.val
                });
            });
            // updates the view on the chart
            chart.update();
        }
        
        // Defines a method for updating the reading display when a reading
        //  comes in from the socket
        function update_list(reading) {
            // check if the output is full
            if (readings.childElementCount === readings_size) {
                // remove the oldest reading
                readings.removeChild(readings.childNodes[0]);
            }
            
            // append the newest reading to the end of the display
            var node = document.createElement("LI");
            // lazily convert reading to a string
            var textNode = document.createTextNode(JSON.stringify(reading));
            node.appendChild(textNode);
            readings.appendChild(node);
        }

    </script>
{% endblock %}
