{% extends 'base.jinja2' %}

{% block head %}
    <!-- Pull down ChartJS for graphing and Moment for time -->
    <script src="https://cdn.jsdelivr.net/combine/npm/moment@2.24.0,npm/chart.js@2.8.0"></script>
    <!-- Hammer and ChartJS Zoom Extension -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@0.7.3"></script>
    <!-- ChartJS Realtime Extension -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@latest/dist/chartjs-plugin-streaming.min.js"></script>
{% endblock %}

{% block header %}
    <h1>{{ title }} - Senslify</h1>
{% endblock %}

{% block content %}
    <h2>Displays Live Data and Recent Readings</h2>
    <section>
        <div class="chart-container" style="position: relative; height:40vh; width:80vw">
            <canvas id="canvas_chart"></canvas>
        </div>
        <h6>Note: Live display will not update if the sensor is offline.</h6>
        <div>
            <!-- Used to indicate the reading type to send from server -->
            <label for="sel_rtype">Reading: </label>
            <select id="sel_rtype" onchange="onStreamChanged();">
                {% for rtype in rtypes %}
                    <option value="{{ rtype.rtypeid }}">{{ rtype.rtype }}</option>
                {% endfor %}
            </select>
        </div>
    </section>
    <section>
        <h3>Last {{ num_readings }} Readings for Sensor {{ sensorid }}:</h3>
        <ol id="list_readings"></ol>
    </section>
{% endblock %}

{% block footer %}
    <!-- The below script handles WebSocket and chart interaction. -->
    <script>
        
        //
        // Define all necessary script variables
        //
        
        // the number of readings to retrieve from the server
        const rlim = {{ num_readings }};
        // the id of the sensor to receive messages for
        const sensorid = {{ sensorid }};
        // the id of the group the sensor belongs to
        const groupid = {{ groupid }};
        // the websocket for sending/receiving messages to/from the server
        //  the websocket is constant as it persists for the life of the page
        const ws = new WebSocket('{{ ws_url }}');
        // stores a reference to the chart object for graphically displaying 
        //  readings
        var rtChart = null;
        
        //
        // Define handlers for the window
        //
        
        /**
         * Fired when the user navigates away from the page.
         * Signals a teardown of the WS at the server as well to teardown the
         * WS on the client.
         */
        function onWindowUnload() {
            var msg = {'cmd': 'RQST_CLOSE', 'sensorid': sensorid};
            ws.send(JSON.stringify(msg));
            ws.close();
        }
        
        // Register JQuery window event handlers
        $(window).on("unload", onWindowUnload);
        
        //
        // Define handlers for the WebSocket
        //
        
        /**
         * Client side WS handler that requests the server to enqueue the 
         * WS representing this client to receive messages for the sensor
         * indicated by sensorid.
         */
        function joinHandler() {
            var rqst = {'cmd': 'RQST_JOIN', 'sensorid': sensorid};
            ws.send(JSON.stringify(rqst));
        }
        
        /**
         * Client side WS handler that handles received messages (readings)
         * from the server. The client only receives readings for the 
         * sensorid and rtypeid that it has registered to receive updates on.
         * @param resp The response from the server.
         */
        function readingHandler(resp) {
            // get the list of readings
            var rlist = $("#list_readings");
            
            // evict the oldest reading if at the limit
            if (rlist.children().length === rlim) {
                rlist.children().last().remove();
            }
            
            // add the reading to the front of the list
            $('<li/>')
                    .text(resp.readings[0].rstring)
                    .prependTo($("#list_readings"));
                    
            // add the reading to the chart
            rtChart.data.datasets[0].data.push({
                x: moment.unix(resp.readings[0].ts).utc(),
                y: resp.readings[0].val
            });
            
            // update the chart, keepiing the current animation
            rtChart.update({
                preservation: true
            });
        }
        
        /**
         * Client side WS handler that handles received messages (a dataset)
         * from the server. The client receives an up-to-date dataset containing
         * the top 100 most recent readings for the sensorid and rtypeid they
         * are registered with.
         * @param resp The response from the server.
         */ 
        function streamHandler(resp) {
            // get the readings from the response
            var readings = resp.readings;
            
            // reset the chart
            resetChart();
            
            // reset the list
            resetList(resp.readings)
        }
        
        /**
         * Client side WS handlet that is fired when the WebSocket is closed.
         * Handles cleaning up after it.
         */
        function onWSClose() {
            // TODO: Cleanup after the WebSocket
        }
        
        /**
         * Client side WS handler that fires when the WebSocket first opens.
         * This is used by the client to register the sensor it wants to
         * receive updates for.
         * @param err An error if one occurs.
         */
        function onWSOpen(err) {
            // Register a listener on the server
            joinHandler();
            // Only get the initial dataset when the document has loaded
            $(document).ready(function() {
                onStreamChanged();
            });
        }
        
        /**
         *
         */
        function onWSReceive(msg) {
            // Parse the response from the server
            var resp = JSON.parse(msg.data);
            
            // route the message based on response command
            if (resp.cmd === "RESP_READING") { // handles individual readings
                readingHandler(resp);
            } else if (resp.cmd = "RESP_STREAM") { // handles whole datasets
                streamHandler(resp);
            }
        }
        
        // Register handlers for the WebSocket
        ws.onopen = onWSOpen;
        ws.onmessage = onWSReceive;
        ws.onclose = onWSClose;
        
        //
        // Define additional support functions
        //
        
        /**
         * Constructs a new ChartJS line chart.
         * @param raw_dataset The dataset to intialize the chart with.
         */
        function createChart() {
            // get the context for the chart
            var ctx = $('#canvas_chart')[0].getContext('2d');
            
            // return the chart
            return new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: "Value over Time",
                        backgroundColor: "rgb(255, 99, 132)",
                        borderColor: "rgb(255, 99, 132)",
                        fill: false,
                        data: []
                    }]
                },
                options: {
                    responsiveness: true,
                    maintainAspectRatio: false,
                    title: {
                        display: true,
                        text: "Time Series for Sensor {{ sensorid }}"
                    },
                    // enable scaling in realtime
                    scales: {
                        xAxes: [{
                            type: 'realtime',
                            distribution: "series",
                            display: true
                        }],
                        yAxes: [{
                            type: 'linear',
                            display: true
                        }]
                    }
                },
                plugins: {
                    zoom: {
		                // Container for pan options
		                pan: {
			                enabled: true,
			                mode: 'xy',
			                rangeMin: {
				                x: null,
				                y: null
			                },
			                rangeMax: {
				                x: null,
				                y: null
			                }
		                },
		                // Container for zoom options
		                zoom: {
			                enabled: true,
			                drag: true,
			                mode: 'xy',
			                rangeMin: {
				                x: null,
				                y: null
			                },
			                rangeMax: {
				                x: null,
				                y: null
			                },
			                speed: 0.1
		                }
	                }
                }
            });
        }
        
        /**
         * Resets the chart with a new dataset.
         * @param dataset The dataset to load into the chart.
         */
        function resetChart() {
            if (rtChart != null) {
                // destroy the original chart
                rtChart.destroy();
            }
            
            // rebuild the chart
            rtChart = createChart();
        }
        
        /**
         * Resets the list with a new dataset.
         * @param dataset The dataset to load into the list.
         */
        function resetList(dataset) {
            // empty display of all children
            $("#list_readings").empty();
            
            // rebuild the list with the new values
            dataset.forEach(function(reading) {
                $('<li/>')
                    .text(reading.rstring)
                    .appendTo($("#list_readings"));
            });
        }
        
        /**
         * Handles onchange events for the rtype selector.
         */
        function onStreamChanged() {
            var rtypeid = $("#sel_rtype").val()
            
            var msg = {
                'cmd': 'RQST_STREAM',
                'sensorid': sensorid,
                'groupid': groupid,
                'rtypeid': rtypeid
            };
            
            ws.send(JSON.stringify(msg));
        }
    </script>
{% endblock %}
